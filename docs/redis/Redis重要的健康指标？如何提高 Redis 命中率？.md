# Redis重要的健康指标？如何提高 Redis 命中率？
## Redis监控指标
**（1）存活情况**

所有指标中最重要的当然是检查redis是否还活着，可以通过命令PING的响应是否是PONG来判断。

**（2）连接数**
连接的客户端数量，可通过命令以下命令查看：
```
src/redis-cli info Clients | grep connected_clients
```
这个值跟使用redis的服务的连接池配置关系比较大，所以在监控这个字段的值时需要注意。另外这个值也不能太大，建议不要超过5000，如果太大可能是redis处理太慢，那么需要排除问题找出原因。

另外还有一个拒绝连接数（rejected_connections）也需要关注，这个值理想状态是0。如果大于0，说明创建的连接数超过了maxclients，需要排查原因。是redis连接池配置不合理还是连接这个redis实例的服务过多等。

**（3）阻塞客户端数量**
blocked_clients，一般是执行了list数据类型的BLPOP或者BRPOP命令引起的，可通过命令以下命令查看，这个值最好应该为0。
```
src/redis-cli info Clients | grep blocked_clients
```
**（4）使用内存峰值**
监控redis使用内存的峰值，Redis可以通过命令config set maxmemory 10737418240设置允许使用的最大内存（强烈建议不要超过20G），为了防止发生swap导致Redis性能骤降，甚至由于使用内存超标导致被系统kill，建议used_memory_peak的值与maxmemory的值有个安全区间，例如1G，那么used_memory_peak的值不能超过9663676416（9G）。另外，还可以监控maxmemory不能少于多少G，比如5G。因为以前生产环境出过这样的问题，运维不小心把10G配置成了1G，从而导致服务器有足够内存却不能使用的悲剧。

**（5）内存碎片率**
mem_fragmentation_ratio=used_memory_rss/used_memory，这也是一个非常需要关心的指标。如果是redis4.0之前的版本，这个问题除了重启也没什么很好的优化办法。而redis4.0有一个主要特性就是优化内存碎片率问题（Memory de-fragmentation）。在redis.conf配置文件中有介绍即ACTIVE DEFRAGMENTATION：碎片整理允许Redis压缩内存空间，从而回收内存。这个特性默认是关闭的，可以通过命令CONFIG SET activedefrag yes热启动这个特性。

    当这个值大于1时，表示分配的内存超过实际使用的内存，数值越大，碎片率越严重。
    当这个值小于1时，表示发生了swap，即可用内存不够。

另外需要注意的是，当内存使用量（used_memory）很小的时候，这个值参考价值不大。所以，建议used_memory至少1G以上才考虑对内存碎片率进行监控。

**（6）缓存命中率**
keyspace_misses/keyspace_hits这两个指标用来统计缓存的命令率，keyspace_misses指未命中次数，keyspace_hits表示命中次数。keyspace_hits/(keyspace_hits+keyspace_misses)就是缓存命中率。视情况而定，建议0.9以上，即缓存命中率要超过90%。如果缓存命中率过低，那么要排查对缓存的用法是否有问题。

**（7）OPS**
instantaneous_ops_per_sec这个指标表示缓存的OPS，如果业务比较平稳，那么这个值也不会波动很大，不过国内的业务比较特性，如果不是全球化的产品，夜间是基本上没有什么访问量的，所以这个字段的监控要结合自己的具体业务，不同时间段波动范围可能有所不同。

**（8）持久化**
rdb_last_bgsave_status/aof_last_bgrewrite_status，即最近一次或者说最后一次RDB/AOF持久化是否有问题，这两个值都应该是"ok"。

另外，由于redis持久化时会fork子进程，且fork是一个完全阻塞的过程，所以可以监控fork耗时即latest_fork_usec，单位是微妙，如果这个值比较大会影响业务，甚至出现timeout。

**（9）失效KEY**
如果把Redis当缓存使用，那么建议所有的key都设置了expire属性，通过以下命令得到每个db中key的数量和设置了expire属性的key的属性，且expires需要等于keys：
```
src/redis-cli info Keyspace

// Keyspace
db0:keys=30,expires=30,avg_ttl=0
db0:keys=23,expires=22,avg_ttl=0
```

（10）慢日志
通过命令slowlog get得到Redis执行的slowlog集合，理想情况下slowlog集合应该为空，即没有任何慢日志，不过有时候由于网络波动等原因造成set key value这种命令执行也需要几毫秒，在监控的时候需要注意，而不能看到slowlog就想着去优化，简单的set/get可能也会出现在slowlog中。

## 如何提高Redis命中率？

    （1）命中：可以直接通过缓存获取到需要的数据。
    （2）不命中：无法直接通过缓存获取到想要的数据，需要再次查询数据库或者执行其它的操作。原因可能是由于缓存中根本不存在，或者缓存已经过期。

通常来讲，缓存的命中率越高则表示使用缓存的收益越高，应用的性能越好（响应时间越短、吞吐量越高），抗并发的能力越强。由此可见，在高并发的互联网系统中，缓存的命中率是至关重要的指标。

### 如何监控缓存的命中率
redis提供了INFO这个命令，能够随时监控服务器的状态，只用telnet到对应服务器的端口，执行命令即可：
```
telnet localhost 6379  
info  
```
在输出的信息里面有这几项和缓存的状态比较有关系：

    keyspace_hits:14414110  
    keyspace_misses:3228654  
    used_memory:433264648  
    expired_keys:1333536  
    evicted_keys:1547380
    
通过计算hits和miss，可以得到缓存的命中率：14414110 / (14414110 + 3228654) = 81% ，一个缓存失效机制，和过期时间设计良好的系统，命中率可以做到95%以上。

### 影响缓存命中率的几个因素
前面提到了缓存命中率的重要性，下面分析下影响缓存命中率的几个因素。

    （1）业务场景和业务需求
        缓存适合“读多写少”的业务场景，否则使用缓存的意义其实并不大，命中率会很低。
        业务需求决定了对时效性的要求，直接影响到缓存的过期时间和更新策略。时效性要求越低，就越适合缓存。在相同key和相同请求数的情况下，缓存时间越长，命中率会越高。
        互联网应用的大多数业务场景下都是很适合使用缓存的。

    （2）缓存的设计（粒度和策略）
        通常情况下，缓存的粒度越小，命中率会越高。
        举个实际的例子说明：当缓存单个对象（细粒度）的时候（例如：单个用户信息），只有当该对象对应的数据发生变化时，才需要更新缓存或者让移除缓存。
        而当缓存一个集合的时候（例如：所有用户数据），其中任何一个对象对应的数据发生变化时，都需要更新或移除缓存。
        还有另一种情况，假设其他地方也需要获取该对象对应的数据时（比如其他地方也需要获取单个用户信息），如果缓存的是单个对象，则可以直接命中缓存，反之，则无法直接命中。这样更加灵活，缓存命中率会更高。
        此外，缓存的更新/过期策略也直接影响到缓存的命中率。当数据发生变化时，直接更新缓存的值会比移除缓存（或者让缓存过期）的命中率更高，当然，系统复杂度也会更高。

    （3）缓存容量和基础设施
        缓存的容量有限，则容易引起缓存失效和被淘汰（目前多数的缓存框架或中间件都采用了LRU算法）。
        同时缓存的技术选型也是至关重要的，例如采用应用内置的本地缓存就比较容易出现单机瓶颈，而采用分布式缓存则毕竟容易扩展。所以需要做好系统容量规划，并考虑是否可扩展。
        此外不同的缓存框架或中间件，其效率和稳定性也是存在差异的。

    （4）其他因素
        当缓存节点发生故障时，需要避免缓存失效并最大程度降低影响，这种特殊情况也是架构师需要考虑的。业内比较典型的做法就是通过一致性Hash算法，或者通过节点冗余的方式。

有些朋友可能会有这样的理解误区：既然业务需求对数据时效性要求很高，而缓存时间又会影响到缓存命中率，那么系统就别使用缓存了。其实这忽略了一个重要因素--并发。通常来讲，在相同缓存时间和key的情况下，并发越高，缓存的收益会越高，即便缓存时间很短。

### 提高缓存命中率的方法
从架构师的角度，需要应用尽可能的通过缓存直接获取数据，并避免缓存失效。这也是比较考验架构师能力的，需要在业务需求，缓存粒度，缓存策略，技术选型等各个方面去通盘考虑并做权衡。尽可能的聚焦在高频访问且时效性要求不高的热点业务上（如字典数据、session、token），通过缓存预加载（预热）、增加存储容量、调整缓存粒度、更新缓存等手段来提高命中率。

    （1）若内存不够导致频繁淘汰内存，则需要增大最大内存配置，或者调整缓存的淘汰策略。 
    （2）若是粒度设计不合理，则更改粒度设计，使粒度变小。但是注意，粒度变小可能同时带来的问题会是内存变大。所以适当考虑对内容做压缩。 
    （3）过期时间的设定，在业务允许的情况下，可以增加缓存的过期时间。 
    （4）若业务场景是访问并发很高，但对数据的时效性要求没有那么高的时候，可以考虑做缓存预热。如果并发度不是很高，访问比较分散的话， 缓存预热反而效果不好。 

对于时效性很高（或缓存空间有限），内容跨度很大（或访问很随机），并且访问量不高的应用来说缓存命中率可能长期很低，可能预热后的缓存还没来得被访问就已经过期了。
