# Redis的线程模型？为什么Redis单线程模型也能效率这么高？为什么采用单线程模型？Redis是单线程的，如何提高多核CPU的利用率？
## Redis的线程模型
Reactor模型有三种：单线程Reactor模型，多线程Reactor模型，主从Reactor模型。Tomcat、Netty都使用了Reactor线程模型来实现IO多路复用，，Tomcat和Netty使用的是主从Reactor模型（主从Reactor模型是最健壮），而Redis是使用单线程Reactor模型。

Redis内部使用文件事件处理器file event handler，这个文件事件处理器是单线程的，所以Redis才叫做单线程的模型。它采用IO多路复用机制同时监听多个Socket，根据Socket上的事件来选择对应的事件处理器进行处理。文件事件处理器的结构包含4个部分：

    （1）多个Socket
    （2）IO多路复用程序
    （3）文件事件分派器
    （4）事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
    
![](/images/redis/Redis线程模型.png)

上图描述了Redis工作的线程模型，模拟了服务端处理客户端命令的过程：
（1）文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，即将套接字的fd注册到epoll上，当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生。
（2）尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都推到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。
（3）此时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。文件事件处理器以单线程方式运行，这就是之前一直提到的Redis线程模型中，效率很高的那个单线程。
    
### Redis线程模型处理流程

![](/images/redis/redis模型流程1.png)

Redis初始化的时候，创建serversocket，并将连接应答处理器与serversocket的AE_READABLE事件进行关联，当客户端01请求建立连接，serversocket会创建一个AE_READABLE事件；然后IO多路复用程序监听到了serversocket的AE_READABLE事件，就将socket压入队列；文件处理会从队列中读取到socket消息，交由对应的时间处理器处理，由于在初始化的时候，已经将AE_READABLE事件于连接应答处理器关联，所以直接交由连接应答处理器处理，连接应答处理器处理完成后，将通过serversocket建立一个与客户端1一一对应的socket01，并将socket01的AE_READABLE事件与命令处理器进行关联。

![](/images/redis/redis模型流程2.png)

客户端建立好连接后，客户端发送命令对Redis数据进行操作。如set a 1，此时会由socket01创建AE_READABLE事件，IO多路复用程序监听到该事件，则将socket消息压入队列中；文件事件分派器从队列中取出socket消息，交由对应的事假处理器处理（上一步中已经将socket01的AE_READABLE事件与命令请求处理器关联），处理完成后，会将socket01的AE_WRITEABLE事件与命令回复处理器进行关联。

![](/images/redis/redis模型流程3.png)

当客户端01要获取执行的结果时，socket01会创建AE_WRITEABLE事件，然后对应的命令处理器就会执行处理，将结果写回到socket01中，返回给客户端。处理完成后，会删除socket01的AE_WRITEABLE事件与命令回复处理器的关联。

## 为什么Redis单线程模型也能效率这么高？
（1）完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。并通过异步的方式将数据写入磁盘。所以 Redis 具有快速和数据持久化的特征。
（2）使用多路I/O复用模型，非阻塞IO，Redis单线程处理大量的并发客户端连接的模型。
（3）采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
（4）丰富的数据结构，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化。例如压缩表，对短数据进行压缩存储；跳表，使用有序的数据结构加快读取的速度。也因为Redis是单线程的，所以可以实现丰富的数据结构，无需考虑并发的问题。
（5）底层使用C语言实现,一般来说,C 语言实现的程序"距离"操作系统更近,执行速度相对会更快;

## 为什么Redis采用单线程模型，而不使用多线程的Reactor模型？
首先要明确，多线程不一定比单线程快，因为多线程还涉及到CPU上下文切换的消耗以及频繁创建、销毁线程的消耗 。那么多线程是为了优化什么而使用的呢？我所了解的有两点：

    （1）充分利用多核CPU的资源，实现并行
        因为多核cpu每一个核心都可以独立执行一个线程，所以多核cpu可以真正实现多线程的并行。
        但这点优化算不上什么，一台服务器上一般部署了很多的应用，哪有那么多空闲的CPU核心空闲着。

    （2）应对CPU的“阻塞”
        认为这才是主要原因。“阻塞”包括网络io、磁盘io等这类io的阻塞，还包括一些执行很慢的逻辑操作等。例如：某个接口的方法中，按照执行顺序分成A、B、C三个独立的部分。
        若每个部分执行的都很慢（如：查询数据库视图，将数据导出excel文件），都要10秒。那么方法执行完成，单线程要用30秒，多线程分别执行只需要10秒。优化了20秒，线程创建和CPU上下文切换的影响，和20秒比起来不算什么。
        若每个部分执行的都很快，都只需要10毫秒。按照上面的计算方式，理论上优化了20毫秒，可线程创建和CPU上下文切换的影响，可是要大于20毫秒的。

因此总体来说，多线程开发对于程序的优化，主要体现在应对导致CPU“阻塞”的点。
而官方表示Redis是基于内存操作，CPU不是Redis的性能瓶颈，Redis的性能瓶颈是机器的内存和网络带宽。这句话怎么理解呢？上面提到过多线程开发对于程序的优化，主要体现在应对导致CPU“阻塞”的点。普通数据库的瓶颈在于磁盘io，可Redis是基于内存操作，没有磁盘io的瓶颈，而且基于Reactor模型，也没有网络io的阻塞。没有多线程的必要，CPU也就不是Redis的性能瓶颈。

另外Redis是将所有的数据全部放在内存中的，所有说使用单线程去操作执行效率就是最高的，多线程在执行过程中需要进行CPU的上下文切换，这个是耗时操作。对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存情况下，这个就是最佳方案。

可以理解成，因为Redis作为内存数据库，又有个很好的线程模型，并不存在io阻塞和CPU等性能瓶颈。再往后可以提升Redis空间的，就在于机器的内存和网络带宽了。

## 为什么不怕Reactor单线程模型的弊端？
Reactor单线程模型的最大缺点在于：Acceptor和Handlers都共用一个线程，只要某个环节发生阻塞，就会阻塞所有。整个尤其是Handlers是执行业务方法的，最容易发生阻塞，像Tomcat就默认使用200容量大线程池来执行。那Redis为什么就不怕呢？

原因就在于Redis作为内存数据库，它的Handlers是可预知的，不会出现像Tomcat那样的自定义业务方法。不过也建议不要在Reids中执行要占用大量时间的命令。

## Redis是单线程的，如何提高多核CPU的利用率
可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的，所以如果想使用多个CPU，可以考虑一下分区。

