# 如何避免缓存”击穿”的问题？
缓存击穿是指某个极度“热点”数据在某个时间点过期时，恰好在这个时间点对这个KEY有大量的并发请求过来，这些请求发现缓存过期一般都会从DB加载数据并回设到缓存，但是这个时候大并发的请求可能会瞬间DB压垮。

![](/images/redis/缓存击穿.jpeg)

对于一些设置了过期时间的KEY，如果这些KEY可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑这个问题。下面是击穿与雪崩、穿透的区别：

    （1）和缓存“雪崩“”的区别在于，前者针对某一KEY缓存，后者则是很多KEY。
    （2）和缓存“穿透“”的区别在于，这个KEY是真实存在对应的值的。
    
![](/images/redis/缓存击穿1.jpeg)
    
## 互斥锁解决方案
请求发现缓存不存在后，去查询DB前，使用分布式锁，保证有且只有一个线程去查询DB，并更新到缓存。其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。流程如下：

![](/images/redis/互斥锁重建缓存.png)

    （1）从Redis获取数据，如果值不为空，则直接返回值，否则执行(2)和(3)。
    （2）如果set(nx和ex) 结果为true（获取分布式锁成功），说明此时没有其他线程重建缓存，那么当前线程执行缓存构建逻辑。
    （3）如果setnx(nx和ex) 结果为false，说明此时已经有其他线程正在执行构建缓存的工作，那么当前线程将休息指定时间(例如这里是50毫秒，取决于构建缓存的速度)后，重新执行函数，直到获取到数据。

## 永远不过期
“永远不过期”包含两层意思：

    （1）从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。
    （2）从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。
    
![](/images/redis/永不过期方案.png)

从实战看，此方法有效杜绝了热点key产生的问题，但唯一不足的就是重构缓存期间，会出现数据不一致的情况，这取决于应用方是否容忍这种不一致。下面代码使用Redis进行模拟：

![](/images/redis/永不过期伪代码.png)

    （1）获取缓存，通过VALUE的过期时间（设置在KEY对应的VALUE里面），判断是否过期。若未过期，则直接返回；若已过期，继续往下执行。
    （2）通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。通过后台的异步线程，通过分布式锁保证有且只有一个线程去查询DB。
    （3）虽然VALUE已经过期，还是直接返回。通过这样的方式，保证服务的可用性，虽然损失了一定的时效性。

## 方案对比
作为一个并发量较大的应用，在使用缓存时有三个目标：第一，加快用户访问速度，提高用户体验。第二，降低后端负载，减少潜在的风险，保证系统平稳。第三，保证数据“尽可能”及时更新。下面将按照这三个维度对上述两种解决方案进行分析。

    （1）互斥锁 (mutex key)：这种方案思路比较简单，但是存在一定的隐患，如果构建缓存过程出现问题或者时间较长，可能会存在死锁和线程池阻塞的风险，但是这种方法能够较好的降低后端存储负载并在一致性上做的比较好。
        因此在缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，可以采用此方案。
    （2）"永远不过期"：这种方案由于没有设置真正的过期时间，实际上已经不存在热点 key 产生的一系列危害，但是会存在数据不一致的情况，同时代码复杂度会增大。
        因此在缓存数据基本不会发生变化的情况下，可以采用此方案。
        若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。
        
上述的两个方案，都是建立在极度“热点”数据存在的情况，所以实际场景下，需要结合如何避免缓存”穿透”的问题？的方案，一起使用。
