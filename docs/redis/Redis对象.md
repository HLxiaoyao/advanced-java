# Redis对象
前面介绍了Redis的几种数据结构，Redis中并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，包括字符串对象、队列对象、哈希对象、集合对象和有序集合对象。使用对象的好处是，可以针对不同的使用场景，为对象设置多种不同的数据结构实现，以达到优化对象在不同场景下的使用效率。
另外，对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象时，这个对象所占用的内存就会被自动释放；Redis还通过引用计数技术实现对象共享机制，这一机制在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。Redis对象还带有访问时间记录信息。

## 对象的类型与编码
Redis使用对象来表示数据库中的键和值，每次在redis中创建一个键值对时，就至少会包含两个对象，一个键对象，一个值对象。redis中的每个对象都由一个redisObject结构表示。

```
typedef struct redisObject{
    //类型REDIS_STRING字符串对象,_LIST对象,等其他对象
    unsigned type:4;
    //编码
    unsigned encoding:4;
    //指向底层实现的数据结构指针
    void *ptr;
    //引用计数
    int refcount;
    //最后一次被命令程序访问的时间
    unsigned lru:22;
}robj
```

### 类型
type属性记录了对象的类型，它可以是下表中的任何一个。对于Redis中保存的键值对来说，键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象或者是有序集合对象。执行Type命令时，返回的结果是数据库键对应的值对象类型，而不是键对象类型。

| 类型常量 | 对象的名称 |
| --- | --- |
| REDIS_STRING | 字符串对象 |
| REDIS_LIST | 列表对象 |
| REDIS_HASH | 哈希对象 |
| REDIS_SET | 集合对象 |
| REDIS_ZSET | 有序集合对象 |

### 编码与底层实现
ptr指针指向对象的底层实现数据结构。而这些数据结构由encoding属性决定。
encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现。

    REDIS_ENCODING_INT : long 类型的整数 ："int"
    REDIS_ENCODING_EMBSTR : embstr编码的简单动态字符串 : "embstr"
    REDIS_ENCODING_RAW : 简单动态字符串 : "raw"
    REDIS_ENCODING_HT : 字典 : "hashtable"
    REDIS_ENCODING_LINKEDLIST : 双端链表 : linkedlist
    REDIS_ENCODING_ZIPLIST : 压缩列表 : "ziplist"
    REDIS_ENCODING_INTSET : 整数集合 : "inset"
    REDIS_ENCODING_SKIPLIST : 跳跃表和字典 : "skiplist"

通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。

例如：在列表对象包含的元素比较少的时候，redis使用压缩类表作为列表对象的底层实现：

    （1）因为压缩列表比双端列表更节约内存，而且在元素数量比较少的时候，在内存中以连续块方式保存的压缩列表比起双端列表可以更快的被载入到缓存中。
    （2）随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失，对象就会将底层的实现从压缩列表改为功能呢个更强大、适合保存大量元素的双端链表上面。
    
## 字符串对象
字符串对象可以选择的编码是int、raw或者embstr。他们的使用情况如下：

    （1）int：一个字符串对象保存的是整数，并且这个整数可以用long类型表示，那么就将这个整数保存在ptr中（将void*转换成long），并将字符串对象编码为int。
    例如：set number 10086    // 10086的值对象就是int编码
    （2）raw：若字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么将用一个SDS来保存这个字符串，并将对象编码设置为raw。
    （3）embstr：若字符串对象保存的是一个字符串值，但长度小于等于32字节，那么字符串对象将使用embstr编码方式。另外用long double类型表示的浮点数在Redis中也是作为字符串值来保存的，若要保存一个浮点数到字符串对象里面，程序会先将这个浮点数转为字符串值，然后再保存转换所得到的字符串值。
    
### raw和embstr的区别
embstr编码是专门用于保存短字符串的一种优化编码方式，它通过调用一次内存分配函数来分配一块连续的空间，空间中的StringObject和SDS紧挨着。而raw编码单独分配StringObject和SDS，需要两次内存分配和回收。

embstr编码的字符串对象执行命令时，产生的效果和raw编码字符串对戏那个执行命令时产生的效果是相同的，但是使用embstr编码有以下好处：

    （1）embstr只需一次内存分配，同时也只需调用一次内存释放函数。
    （2）embstr编码的字符串对象的所有数据在同一块连续的内存中，更好的利用缓存带来的优势，但是 embstr 是只读的，不能进行修改，当一个 embstr 编码的字符串对象进行 append 操作时， redis 会现将其转变为 raw 编码再进行操作。
    
### 编码转换
在int和embstr编码的字符串在条件满足的情况下会自动转化为raw编码。

    （1）对于int编码的字符串对象，若向对象执行了一些命令，使这个对象保存的值不再是整数值，而是一个字符串值，那么字符串对象将从int变为raw。
    （2）Redis中没有embstr编码的字符串对象的任何修改程序，因此embstr编码的字符串实际上是只读的。当对embstr执行任何修改命令时，程序会将对象编码转换成raw，然后再执行修改命令，因此embstr编码的字符串对象执行修改命令之后，总会变成一个raw编码的字符串对象。
    
## 列表对象
列表对象可以是ziplist或者linkedlist。
ziplist是为了尽可能地节约内存而设计的特殊编码双端链表。它的所有元素在内存中紧挨在一起，却又不能通过下标访问。
LinkedList是以链表的形式，每个节点是一个字符串对象。字符串对象是Redis五种类型的对象中唯一一种会被其他四种对象嵌套的对象。

例如：RPUSh numbers 1 "three" 5
若numbers键的值对象使用的是ziplist编码：

若numbers键的值对象使用的是linkedlist编码：


### 编码转换
当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：

    （1）列表对象保存的所有字符串元素的长度都小于64字节；
    （2）列表对象保存的元素数量小于512个；
    不能满足这两个条件的列表对象需要使用linkedlist编码。若其中某一个条件不能满足时，对象的编码转换操作就会被执行。以上两个条件的上限值是可以修改的。list-max-ziplist-value和list-max-ziplist-entries。
    
## 哈希对象
哈希对象可用的编码是ziplist或者hashtable。
ziplist方式的哈希对象使用ziplist作为底层数据结构，当有新的键值对加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入压缩列表表尾。因此：

    （1）保存同一个键值对的两个节点紧挨在一起，键节点在前，值节点在后。插入到压缩列表末尾。
    （2）先添加到哈希对象中的键值对会被放在压缩列表的表头方向。
    
hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：

    （1）字典的每个键都是一个字符串对象，对象中保存了键值对的键；
    （2）字典的每个值都是一个字符串对象，对象中保存了键值对的值。
    
举例：HSET profile name "Tom"
     HSET profile age 25
     HSET profile career "Programmer"
     
### 编码转换
当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：

    （1）哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；
    （2）哈希对象保存的键值对数量小于512个；
    以上两个条件的上限值是可以修改的。hash-max-ziplist-value和hash-max-ziplist-entries。若其中某一个条件不能满足时，对象的编码转换操作就会被执行。原本保存在压缩列表里的所有键值都会被转移并保存到字典里面。
    
## 集合对象
集合对象的编码可以是intset或者hashtable。
intset编码使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。
hashtable编码使用字典（类似于Java中的HashMap）作为底层实现。字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，字典的值则全部被设置为NULL。

举例：SADD numbers 1 3 5

举例：SADD Dfruits "apple" "banana" "cherry"

### 编码转换
当下面两个条件都被满足时，使用intset编码，否则，使用hashtable编码

    （1）集合对象保存的所有元素都是整数值
    （2）集合对象保存的元素数量不超过512
    第二个条件的上限可以通过配置文件修改。set-max-intset-entries。当两个条件中任一个不满足时，就会自动执行编码转换操作，原本保存在整数集合中的所有元素都会被保存到字典里面。
    
## 有序集合对象
有序集合的编码可以是ziplist或者skiplist。
ziplist底层使用压缩列表，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），第二个节点保存元素的分值（Score）。压缩列表内按照分值升序排列。分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。
skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：

```
typedef struct zset {

    // 字典，保存了成员到分值的映射。键为成员，值为分值
    // 用于支持 O(1) 复杂度的按成员取分值操作。ZSCORE命令就是根据这一特性实现的，而其他有序集合命令都在实现内部用到了这一特性。
    dict *dict;

    // 跳跃表，按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素；跳跃表节点的Object属性保存了元素的成员，而跳跃表的score属性则保存了元素的分值。通过跳跃表，程序可以对有序集合进行范围型操作。
    // 用于支持平均复杂度为 O(log N) 的按分值定位成员操作
    // 以及范围操作
    zskiplist *zsl;

} zset;
```

有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。虽然zset结构同时使用跳跃表和字典保存有序集合元素，但是这两种数据结构都会通过指针来共享相同元素的成员和分值。

之所以同时采用两种数据结构来实现，是为了互相弥补对方的不足。zskiplist是为了弥补哈希表不能进行范围查询的缺点，而哈希表将单个元素的查询操作从zskiplist的O(logN)优化到了哈希表的O(1)。

举例：ZADD price 8.5 apple 5.0 banana 6.0 cherry

### 编码转换
当有序集合对象同时满足以下两个条件时，对象使用ziplist编码：

    （1）有序集合保存的元素数量小于128个；
    （2）有序集合保存的所有元素成员的长度都小于64字节。
    
不能满足任何一个，则使用skiplist编码。以上两个条件的上限值是可以在配置文件里修改的，zset-max-ziplist-value和zset-max-ziplist-entries。当两个条件的任何一个不被满足时，程序会自动执行编码转换操作。

## 类型检查与命令多态
Redis中用于操作键的命令基本上可以分为两种类型。

    （1）其中一种是可以对任何类型的键执行，比如：del、expire、rename、type、object等。
    （2）另一种命令只能对特定类型的键执行。比如：
        SET、GET、APPEND、STRLEN等命令只能对字符串键执行；
        HDEL、HSET、HGET、HLEN等命令只能对哈希键执行；
        RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行；
        SADD、SPOP、SINTER、SCARD等命令只能对集合键执行；
        ZADD、ZCARD、RANK、ZSCORE 等命令只能对有序集合键执行；
        
当用SET命令创建一个字符串键，然后用GET命令和APPEND命令操作这个键，但如果我们试图对这个字符串键执行只有列表键才能执行的LLEN命令，那么Redis将向我们返回一个类型错误。

### 类型检查的实现
为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前， Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：

    （1）在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；
    （2）否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。

举个例子，对于LLEN命令来说：

    （1）在执行LLEN命令之前，服务器会先检查输入数据库键的值对象是否为列表类型，即检查值对象redisObject结构type属性的值是否为 REDIS_LIST，如果是的话，服务器就对键执行LLEN命令；
    （2）否则的话，服务器就拒绝执行命令并向客户端返回一个类型错误；

### 多态命令的实现
Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。

例如，列表对象有ziplist和linkedlist两种编码可用，其中前者使用压缩列表 API来实现列表命令，而后者则使用双端链表API来实现列表命令。若对一个键执行LLEN命令，那么服务器除了要确保执行命令的是列表键之外，还需要根据键的值对象所使用的编码来选择正确的LLEN命令实现：

    （1）若列表对象的编码为ziplist，那么说明列表对象的实现为压缩列表， 程序将使用ziplistLen函数来返回列表的长度；
    （2）列表对象的编码为linkedlist，那么说明列表对象的实现为双端链表，程序将使用listLength函数来返回双端链表的长度；
    
可以认为LLEN命令是多态（polymorphism）的。只要执行LLEN命令的是列表键， 那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行。例如：LLEN命令从类型检查到根据编码选择实现函数的整个执行过程，其他类型特定命令的执行过程也是类似的。

## 内存回收
C语言并不具备自动的内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制，通过这一机制， 程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。每个对象的引用计数信息由redisObject结构的refcount属性记录。对象的引用计数信息会随着对象的使用状态而不断变化：

    （1）在创建一个新对象时，引用计数的值会被初始化为1；
    （2）当对象被一个新程序使用时，它的引用计数值会被增一；
    （3）当对象不再被一个程序使用时，它的引用计数值会被减一；
    （4）当对象的引用计数值变为0时，对象所占用的内存会被释放。
    
## 对象共享
除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。例如：键A创建了一个包含整数值100的字符串对象作为值对象，这时键B也要创建一个同样保存了整数值100的字符串对象作为值对象。那么服务器会让键A和键B共享同一个字符串对象。在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：

    （1）将数据库键的值指针指向一个现有的值对象；
    （2）将被共享的值对象的引用计数增一。
    
举例：包含整数值100的字符串对象同时被键A和键B共享之后的样子，可以看到，除了对象的引用计数从之前的1变成了2之外，其他属性都没有变化。

![](/images/redis/对象共享示例.png)

共享对象机制对于节约内存非常有帮助， 数据库中保存的相同值对象越多， 对象共享机制就能节约越多的内存。

目前Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到 9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。

创建共享字符串对象的数量可以通过修改redis.h/REDIS_SHARED_INTEGERS 常量来修改。当创建一个值为100的键A，并使用OBJECT REFCOUNT命令查看值对象的引用计数为2。引用这个值对象的两个程序分别是持有这个值对象的服务器程序，以及共享这个值对象的键A，当再创建一个值为100的键B，那么键B也会指向包含整数值100的共享对象，使得共享对象的引用计数值变为3。

### 可以共享对象的数据结构
这些共享对象不单单只有字符串键可以使用，在数据结构中嵌套了字符串对象的对象（linkedlist编码的列表对象、hashtable编码的哈希对象、hashtable编码的集合对象、以及zset编码的有序集合对象）都可以使用这些共享对象。

为什么Redis不共享包含字符串的对象？

    当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多：
    （1）如果共享对象是保存整数值的字符串对象，那么验证操作的复杂度为 O(1) ；
    （2）如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为 O(N)；
    （3）如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2)。
    因此，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制， Redis只对包含整数值的字符串对象进行共享。
    
## 对象的空转时长
redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间。OBJECT IDLETIME命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的。OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。

键的空转时长还有另外一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。