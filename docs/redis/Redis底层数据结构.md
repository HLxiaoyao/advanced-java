# Redis底层数据结构
## 简单动态字符串SDS
Redis没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string SDS）的抽象类型，并将SDS用作Redis 的默认字符串表示。

### SDS的定义
```
/*  
 * 保存字符串对象的结构  
 */  
struct sdshdr {   
    // buf 中已占用空间的长度  
    int len;  
    // buf 中剩余可用空间的长度  
    int free;  
    // 数据空间  
    char buf[];  
}; 
```

![](/images/redis/SDS.png)

    （1）len变量：用于记录buf中已经使用的空间长度（这里指出Redis 的长度为5），表示这个SDS保存了一个五个字节长的字符串。
    （2）free变量：用于记录buf中还空余的空间（初次分配空间，一般没有空余，在对字符串修改的时候，会有剩余空间出现）
    （3）buf字符数组：这是一个char类型的数组，用于记录我们的字符串（记录Redis）。
    
SDS遵循了C字符串以空格字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符串分配额外的1字节的空间以及添加空字符到字符串末尾等操作，都是有SDS函数完成的，对开发者了来说是透明的。
    
### SDS与C字符串的区别
传统的C字符串使用长度为N+1的字符串数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符‘\0’，这样做在获取字符串长度，字符串扩展等操作的时候效率低下。C语言使用这种简单的字符串表示方式，并不能满足Redis对字符串在安全性、效率以及功能方面的要求。

**（1）常数复杂度获取字符串长度：**
传统的C字符串使用长度为N+1的字符串数组来表示长度为N的字符串，所以为了获取一个长度为C字符串的长度，必须遍历整个字符串。和C字符串不同，SDS的数据结构中，有专门用于保存字符串长度的变量，我们可以通过获取len属性的值，直接知道字符串长度。

**（2）杜绝缓冲区溢出：**
C字符串不记录字符串长度，除了获取的时候复杂度高以外，还容易导致缓冲区溢出。而Redis中SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性。当我们需要对一个SDS进行修改的时候，redis会在执行拼接操作之前，预先检查给定SDS空间是否足够，如果不够，会先拓展SDS的空间，然后再执行拼接操作。

假设程序中有两个在内存中紧邻着的字符串s1和s2，其中s1保存了字符串“redis”，二s2则保存了字符串“MongoDb”。若将s1的内容修改为redis cluster，但是又忘了重新为s1分配足够的空间，这时候就会出现以下问题，原本s2中的内容已经被S1的内容给占领了，s2现在为cluster，而不是“Mongodb”。而 Redis 中SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性。

**（3）减少修改字符串时带来的内存重分配次数：**
  C语言字符串在进行字符串的扩充和收缩的时候，都会面临着内存空间的重新分配问题。
    
    （1）字符串拼接会产生字符串的内存空间的扩充，在拼接的过程中，原来的字符串的大小很可能小于拼接后的字符串的大小，那么这样的话，就会导致一旦忘记申请分配空间，就会导致内存的溢出。
    （2）字符串在进行收缩的时候，内存空间会相应的收缩，而如果在进行字符串的切割的时候，没有对内存的空间进行一个重新分配，那么这部分多出来的空间就成为了内存泄露。
    
为了避免C字符串中的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数据长度之间的关联，通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。

    （1）空间预分配：空间预分配用于优化SDS字符串增长操作。当对SDS进行空间扩展时，不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间，分配策略如下：
    对SDS进行修改之后，SDS的长度（len属性的值）小于1MB，那么成为分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。
    若对SDS进行修改之后，SDS的长度（len属性的值）将大于等于1MB，那么程序会分配1MB的未使用空间。
    通过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。
    
    （2）惰性空间释放：SDS的free是用于记录空余空间的。除了在拓展字符串的时候会使用到free来进行记录空余空间以外，在对字符串进行收缩的时候，也可以使用free属性来进行记录剩余空间，这样做的好处就是避免下次对字符串进行再次修改的时候，需要对字符串的空间进行拓展。然而，但是并不是说不能释放SDS中空余的空间，SDS提供了相应的API，在有需要的时候，自行释放SDS的空余空间。通过惰性空间释放，SDS避免了缩短字符串时所需的内存重分配操作，并未将来可能有的增长操作提供了优化。

**二进制安全：**
C字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存想图片，音频，视频，压缩文件这样的二进制数据。但是在Redis中，不是靠空字符来判断字符串的结束的，而是通过len这个属性。那么，即便是中间出现了空字符对于SDS来说，读取该字符仍然是可以的。

## 链表

## 字典
字典又称为符号表、关联表或者映射(map)，是一种保存键值对的抽象数据结构。在字典中的每个key都是独一无二的，程序可以在字典中根据健查找与之关联的值。redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每一个哈希表节点就保存了字典中的一个键值对。

### 字典的定义
Redis字典所使用的哈希表由dict.h/dictht结构定义：
```
// 字典
typedef struct dict{
   //类型特定函数，该属性指向dictType结构指针。每个dictType结构保存了一簇用于操作特定类型键值对的函数，比如计算hash值的函数,复制函数,键对比函数等.
    dictType *type;
    //私有数据
    void *privdata;
    //哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。
    dictht ht[2];
    // rehash索引，它记录了rehash目前的进度。当rehash不在进行时,值为-1
    in trehashidx;
}dict

// 字典中的哈希表
typedef struct dictht{
   //哈希表数组
   dictEntry **table;
   //哈希表大小(哈希表总的空间大小)
   unsigned long size;
   //哈希表大小烟吗,用于计算索引值
   //sizemask=size-1;
   unsigned long sizemask;
   //该哈希表已有节点的数量(哈希表中的真实的节点数量)
   unsigned long used;
}dictht


// 哈希表节点
typedef struct dictEntry{
    //键
    void *key;

    // 保存键值对中的值，值可以是一个指针，或者是一个uint64_t整数、int64_t整数
     union{
        void *val;
        uint64_tu64;
        int64_ts64;
    }v;
    //指向下一个哈希表节点,形成链表。以此来解决哈希冲突问题。
    struct dicEntry *next;
} dicEntry
```

![字典](/images/redis/字典.png)

### 哈希算法
在将一个新的键值对添加到字典时，需要先计算出哈希值和索引值，然后根据索引值，将新键值对的哈希表节点放到哈希数组的指定索引上。redis计算哈希值和索引值的方法如下：

    （1）根据key计算hash值：
    hash = dict->type->hashFunction(key);

    （2）使用哈希表的sizemask属性和哈希值,计算出索引值。根据情况不同,ht[x]可以是ht[0],或者ht[1]
    index = hash& dict->ht[x].sizemask;
    
### 哈希冲突
当两个或两个以上的键被分配到哈希表数组的同一个索引上面，即发生了键冲突。Redis使用链地址法来解决键冲突，即每一个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表。
但是由于dicEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置。

### rehash
随着对哈希表的不断操作，哈希表保存的键值对会逐渐的发生改变，为了让哈希表的负载因子维持在一个合理的范围之内，我们需要对哈希表的大小进行相应的扩展或者压缩，这时候，我们可以通过 rehash（重新散列）操作来完成。执行rehash的步骤如下：

    （1）给ht[1]分配空间
        扩展操作时，为字典ht[1]分配空间的大小为ht[0].used*2的最近最大的一个2的n次方(2的n次方幂)。
        收缩操作时，为字典ht[1]分配空间的大小为ht[0].used最近最大的一个的2的n次方。
    
    （2）将ht[0]中的所有键值对移动到ht1[1]上面，rehash指的是重新计算键的哈希值和索引值。
    （3）当ht[0]中的键值对都移动到ht1[0]时，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白的哈希表。
    
举个列子如下：
执行rehash之前的字典：

![](/images/redis/执行rehash之前的字典.png)

执行扩展操作，为ht[1]分配空间为8：

![](/images/redis/执行扩展操作.png)

ht[0]数据转移，将ht[0]中的数据转移到ht[1]中，在转移的过程中，需要对哈希表节点的数据重新进行哈希值计算。

![](/images/redis/数据转移.png)

释放ht[0]，ht[1]设置为ht[0]，为ht[1]分配一个空白的哈希表。

![](/images/redis/释放.png)

**（1）哈希表的扩容与收缩：**
当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：

    （1）服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1；
    （2）服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5；
    
其中哈希表的负载因子的计算如下：

    load_factor = ht[0].used/ ht[0].size

当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

**（2）渐进式rehash：**
ht[0]里面的所有键值对rehash到ht[1]里面时，并不是一次性、集中式的完成，而是分多次、渐进式的完成。假如ht[0]里面保存了上千万个键值对，一次性完成，需要大量的计算量，可能会导致服务在一点时间内停止服务。为了避免rehash对服务性能造成的影响，ht[0]里面所有的键值对都是分多次渐进式的移动。渐进式ruhash的步骤如下：

    （1）为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表
    （2）在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash开始
    （3）在rehash进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash到ht[1]表中，并且将rehashidx加一
    （4）当ht[0]中所有数据转移到ht[1]中时，将rehashidx设置成-1，表示rehash结束
    
**（3）渐进式rehash执行期间的哈希表操作：**
因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。比如在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，若没找到的话，就会继续到 ht[1]里面进行查找，诸如此类。

另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到 ht[1]里面，而ht[0]则不再进行任何添加操作。这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。

**（4）渐进式rehash带来的问题：**
渐进式rehash避免了redis阻塞，可以说非常完美，但是由于在rehash时，需要分配一个新的hash表，在rehash期间，同时有两个hash表在使用，会使得redis内存使用量瞬间突增，在Redis满容状态下由于Rehash会导致大量Key驱逐。

## 跳跃表skiplist
跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表是一种随机化的数据,跳跃表以有序的方式在层次化的链表中保存元素，效率和平衡树媲美 ——查找、删除、添加等操作都可以在对数期望时间下完成，并且比起平衡树来说，跳跃表的实现要简单直观得多。Redis 只在两个地方用到了跳跃表，一个是实现有序集合键，另外一个是在集群节点中用作内部数据结构。

### 跳跃表定义
```
// 跳跃表定义
typedef struct zskiplist {
     //表头节点和表尾节点
     structz skiplistNode *header,*tail;
     //表中节点数量（表头节点不计算在内）
     unsigned long length;
     //表中层数最大的节点的层数（表头节点的层数不计算在内）
     int level;
}zskiplist;

// 跳跃表节点定义
typedef struct zskiplistNode{
　　// 层，level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，可以通过这些层加快访问其他节点的速度，层数越多，访问其他节点越快。
　　每次创建一个新的跳跃表节点的时候，根据幂等定律随机生成一个介于1和32之间的值作为level数组的大小。
   struct zskiplistLevel{
　　　　　//前进指针
        struct zskiplistNode *forward;
　　　　 //跨度，记录了前进指针所指向节点和当前节点的距离。当程序从表头向表尾遍历时，访问会沿着层的前进指针进行。
　　　　 指向null的所有前进指针的跨度都为0，因为他们没有连向任何节点。跨度实际上是用来计算排位的，在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。
        unsigned int span;
    } level[];
　　//后退指针，后退指针每次只能退至前一个节点（即后退一步）
    struct zskiplistNode *backward;
　　//分值，在跳跃表中节点按各自所保存的分值从小到大排列
    double score;
　　//成员对象，指向一个字符串对象，而字符串对象则保存着一个SDS值。在同一个跳跃表中各个节点保存的对象必须是唯一的，但是各个节点保存的分值可以是相同的。
    robj *obj;
}
```

![](/images/redis/跳跃表.png)

## 整数集合
整数集合是集合键的底层实现之一，当一个集合中只包含整数，且这个集合中的元素数量不多时，redis就会使用整数集合intset作为集合的底层实现。可以这样理解整数集合，他其实就是一个特殊的集合，里面存储的数据只能够是整数，并且数据量不能过大。

### 整数集合的定义
```
typedef struct intset{
    //编码方式
    uint32_t enconding;
   // 集合包含的元素数量
    uint32_t length;
    //保存元素的数组，整数集合中的每个元素都是该数组中的一项，并且各项在数组中按值的大小从小到大有序排列，并且数组中不包含任何重复项。  
    int8_t contents[];
} 
```

![](/images/redis/整数集合.png)

虽然contents属性被声明为int8_t类型的数组，但是实际上contents数组中并不保存任何int8_t类型的值，数组中真正类型取决于enconding属性的值。

    （1）encoding=intset_enc_int16，表示集合保存的都是int16类型的整数值。
    （2）若是intset_enc_int64,则表示集合保存的都是int64类型的整数值。
    （3）若是intset_enc_int32，则表示集合保存的都是int32类型的整数值。

数组大小的计算:sizeof(int16_t)*length=16*4 ,如果是int64,就是64*length

### 整数集合升级
因为C语言是静态类型语言,为了避免错误,通常不会将两种类型的值存放到一起.比如int16_t类型的数组只会用来保存int16类型的值,而32位类型的值只会用int32_t类型的数组来保存.

但是Redis中可以通过自动升级来完成，整个集合中可以任意的存储16、32、64位的数据。而不需要用户关心内存溢出的问题。当将一个新元素添加到整数集合中时，若新元素比整数集合中现有元素类型都要长时，整数集合需要先进行升级，才能将新元素添加到整数集合中。升级步骤如下：

    （1）根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
    （2）将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，保证底层数组的有序性质不变。
    （3）将新元素加入到底层数组中。
    
因为每次向整数结合添加新元素都可能会引起升级，二每次升级都需要对底层中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度是O(N)。

举例：现有一个intset_enc_int16编码的整数集合，集合中包含三个int16_t类型的元素，然后将类型为int32_t的整数值添加到整数集合里面。这时整数集合要进行自动升级。

### 升级的好处
1、提升灵活性，可以随意将多种类型的整数添加到集合中，而不必担心出现类型错误。

2、节约内存。整数集合可以同时保存三种不同类型的值，但又确保升级只会在有需要的时候进行，这可以尽量节省内存。

### 降级
整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

## 压缩列表ziplist
压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且列表项要么是小整数值，要么就是比较短的字符串。那么Redis就会使用压缩列表来做列表键的底层实现。

### 压缩列表的构成
压缩列表是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。

| zlbytes | zltail | zllen | entry1 | entry2 | .... | entryN | zlend |
| --- | --- | --- | --- | --- | --- | --- | --- |

    （1）zlbytes：uint32_t类型，4个字节，记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配或者计算zlend的位置时使用。
    （2）zltail：uint32_t类型，4个字节，记录压缩列表尾节点距离压缩列表的起始地址有多少字节。通过这个偏移量，可以不进行遍历确定表尾节点的地址。
    （3）zllen：uint16_t类型，2个字节，记录压缩列表的节点数。当节点数< 65535(16_max)时表示节点的真实数量，大于这个值的时候，则需要遍历整个列表.
    （4）entryX：这个就是数据存储的列表节点。节点的长度由节点保存的内容决定。
    （5）zlend：uint8_t类型，1个字节，用于标记压缩列表的末端。用0xFF表示。
    
### 压缩列表节点的构成
每个压缩列表节点可以保存一个字节数组或者一个整数值，其中字节数组可以是以下三种长度：

    （1）长度小于等于63（2^6 - 1）字节的字节数组。
    （2）长度小于等于16383（2^14 - 1）字节的字节数组。
    （3）长度小于等于4294967295（2^32 - 1）字节的字节数组。
    
整数值可以是以下六种长度：

    （1）4位长，介于0 ～12之间的无符号整数。
    （2）1字节长的有符号整数。
    （3）3字节长的有符号整数。
    （4）uint16_t类型整数。
    （5）uint32_t类型整数。
    （6）uint64_t类型整数。

压缩列表的节点构成如下：
  
| previous_entry_length | encoding | content |
| --- | --- | --- |

    （1）previous_entry_length：属性以字节为单位，记录了压缩列表中前一个节点的长度。如果前一个节点的长度小于254个字节，则previous的使用1个字节来记录。如果前一个节点大于254字节，那么previous则使用5个字节来记录前一个节点的长度。其中属性的第一个字节会被设置为OxFE，而之后的四个字节用来保存前一个节点的长度。
    （2）encoding：记录了节点的content属性所保存数据的类型以及长度。最高位11表示content是整数编码,其他00,01,10表示content是字符串编码
    （3）content：保存节点的值.节点值的类型和长度有encoding属性决定
    
