# Redis有几种数据“过期”策略？Redis有哪几种数据“淘汰”策略？
## 设置键的生存时间或过期时间
通过EXPIRE、PEXPIRE、EXPIREAT和PEXPIREAT四个命令，客户端可以给某个存在的键设置过期时间，当键的过期时间到达时，键就不再可用，并且服务器会自动删除生存时间为0的键。

    （1）EXPIRE、PEXPIRE以秒或毫秒精度设置键的生存时间。
    （2）EXPIREAT、PEXPIREAT以秒或毫秒精度设置键的过期时间，过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器会自动从数据库中删除这个键。
    （3）TTL和PTTL命令接受一个带有生存时间或过期时间的键，返回这个键的剩余生存时间。
    
### 设置过期时间
Redis有四个命令可以设置键的生存时间（可以存活多久）和过期时间（什么时候到期）：

    （1）EXPIRE key ttl 以秒为单位设置键的生存时间为ttl秒；
    （2）PEXPIRE key ttl 以毫秒为单位设置键的生存时间为ttl毫秒；
    （3）EXPIREAT 以秒为单位，设置键的过期 UNIX 时间戳；
    （4）PEXPIREAT 以毫秒为单位，设置键的过期 UNIX 时间戳。

虽然有那么多种不同单位和不同形式的设置方式，所有命令的效果最后都和 PEXPIREAT命令的效果一样，即都是通过PEXPIREAT命令来实现的。举例，从EXPIRE命令到PEXPIREAT命令的转换可以用伪代码表示如下：
```
def EXPIRE(key, sec):
    # 将 TTL 从秒转换为毫秒
    ms = sec_to_ms(sec)
    # 获取以毫秒计算的当前 UNIX 时间戳
    ts_in_ms = get_current_unix_timestamp_in_ms()
    # 毫秒 TTL 加上毫秒时间戳，就是 key 到期的时间戳
    PEXPIREAT(ms + ts_in_ms, key)
```

### 保存过期时间
在数据库中，所有键的过期时间都被保存在redisDb结构的expires字典（过期字典）里。

    （1）过期字典的键是一个指针，这个指针指向键空间中的某个键对象。
    （2）过期字典的键是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间，一个毫秒精度的UNIX时间戳。

```
typedef struct redisDb {
    // ...

    dict *expires;

    // ...
} redisDb;
```

![](/images/redis/过期字典.png)

举例：PEXPIREAT message 1391234400000

![](/images/redis/过期字典举例.png)

### 移除过期时间
PERSIST <key>命令用于移除键key的过期时间，该命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。

例如：PERSIST book
数据库执行得到的结果如下：

![](/images/redis/移除过期时间.png)

### 计算并返回剩余生存时间
TTL命令以秒为单位返回键的剩余生存时间。PTTL命令以毫秒为单位返回键的剩余生存时间。两个命令是通过计算过期时间与当前时间之间的差来实现的。

### 过期键的判定
通过 expires 字典，可以用以下步骤检查某个键是否过期：

    （1）检查键是否存在于expires字典：如果存在，那么取出键的过期时间；
    （2）检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则，键未过期。

可以用伪代码来描述这一过程：
```
def is_expired(key):
    # 取出键的过期时间
    key_expire_time = expires.get(key)
    # 如果过期时间不为空，并且当前时间戳大于过期时间，那么键已经过期
    if expire_time is not None and current_timestamp() > key_expire_time:
        return True
    # 否则，键未过期或没有设置过期时间
    return False
```

## 过期键的删除策略
若一个键是过期的，那它什么时候会被删除？有以下三种删除策略。

    （1）定时删除：在设置键的过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作。
    （2）惰性删除：放任键过期不管，但是在每次从dict字典中取出键值时，要检查键是否过期，如果过期的话，就删除它，并返回空；如果没过期，就返回键值。
    （3）定期删除：每隔一段时间，对expires字典进行检查，删除里面的过期键。
    
### 定时删除
定时删除策略对内存是最友好的，因为它保证过期键会在第一时间被删除，过期键所消耗的内存会立即被释放。不会造成内存浪费。
但缺点是对CPU时间是最不友好的，因为在过期键比较多的情况下，删除过期键操作可能会占用大量的CPU时间，在内存不紧张、但是CPU时间非常紧张的时候（比如说，进行交集计算或排序的时候），将CPU时间花在删除那些和当前任务无关的过期键上，这种做法毫无疑问会是低效的。

除此之外，目前Redis事件处理器对时间事件的实现方式是无序链表，查找一个时间复杂度为O(N)，并不适合用来处理大量时间事件。
### 惰性删除
惰性删除对CPU时间来说是最友好的，它只会在取出键时进行检查，这可以保证删除操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。

惰性删除的缺点是，它对内存是最不友好的，如果一个键已经过期，而这个键又仍然保留在数据库中，那么dict字典和expires字典都需要继续保存这个键的信息，只要这个过期键不被删除，它占用的内存就不会被释放。

在使用惰性删除策略时，如果数据库中有非常多的过期键，但这些过期键又正好没有被访问的话，那么它们就永远也不会被删除（除非用户手动执行），这对于性能非常依赖于内存大小的Redis来说，肯定不是一个好消息。
### 定期删除
上面两种删除方式在单一使用时都有明显的缺陷：定时删除占用太多CPU时间， 惰性删除浪费太多内存。定期删除是这两种策略的一种折中。

Redis将serverCron作为时间事件来运行，从而确保它每隔一段时间就会自动运行一次，在Redis 2.6版本中，程序规定serverCron每秒运行10次，平均每100毫秒运行一次。从Redis2.8开始，用户可以通过修改server.hz选项来调整serverCron的每秒执行次数。
 
定期删除，这里的“定期”指的是Redis定期触发的清理策略，由位于src/redis.c的activeExpireCycle(void)函数来完成。serverCron是由redis的事件框架驱动的定位任务，这个定时任务中会调用activeExpireCycle函数，针对每个db在限制的时间REDIS_EXPIRELOOKUPS_TIME_LIMIT内近可能多的删除过期key，之所以要限制时间是为了防止过长时间的阻塞影响redis的正常运行。这种主动删除策略弥补了被动删除策略在内存上的不友好。

因此，Redis会周期性的随机测试一批设置了过期时间的key并进行处理。测试到的已过期的key将被删除。典型的方式为Redis每秒做10次如下的步骤：

    （1）随机测试100个设置了过期时间的key
    （2）删除这100个中所有发现的已过期的key
    （3）若删除的key超过25个则重复步骤1
    
redis持续清理过期的数据直至将要过期的key的百分比降到了25%以下。Redis-3.0.0每秒钟调用10次后台任务。 除了主动淘汰的频率外，Redis通过timelimit参数对每次淘汰任务执行的最大时长也有一个限定，这样保证了每次主动淘汰不会过多阻塞应用请求。

server.hz调大将会提高Redis主动淘汰的频率，若Redis存储中包含很多冷数据占用内存过大的话，可以考虑将这个值调大，但Redis作者建议这个值不要超过100。实际线上将这个值调大到100，观察到CPU会增加2%左右，但对冷数据的内存释放速度确实有明显的提高（通过观察keyspace个数和used_memory大小）。 

可以看出timelimit和server.hz是一个倒数的关系，也就是说server.hz配置越大，timelimit就越小。换句话说是每秒钟期望的主动淘汰频率越高，则每次淘汰最长占用时间就越短。这里每秒钟的最长淘汰占用时间是固定的250ms（1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/100），而淘汰频率和每次淘汰的最长时间是通过server.hz参数控制的。 

总结：它每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，以此来减少删除操作对CPU时间的影响。另一方面，通过定期删除过期键它，有效地减少了因惰性删除而带来的内存浪费。定期删除策略的难点是确定删除执行的时长和频率。

### redis使用的策略
Redis使用的过期键删除策略是惰性删除加上定期删除，这两个策略相互配合，可以很好地在合理利用CPU时间和节约内存空间之间取得平衡。

**（1）过期键的惰性删除策略：**实现过期键惰性删除策略的核心是db.c/expireIfNeeded函数，所有命令在读取或写入数据库之前，程序都会调用 expireIfNeeded对输入键进行检查。所以每个命令的实现函数都必须能同时处理键存在以及键不存在这两种情况。

    （1）若输入键已过期，则该函数会将输入键从数据库删除。
    （2）若输入键未过期，则该函数不做动作。
    
**（2）定期删除策略的实现：**对过期键的定期删除由redis.c/activeExpireCycle函执行：每当Redis的服务器周期性操作serverCron函数执行时，activeExpireCycle都会被调用。这个函数在规定的时间限制内，尽可能地遍历各个数据库的expires字典，随机地检查一部分键的过期时间，并删除其中的过期键。整个过程可以用伪代码描述如下：

```
def activeExpireCycle():
    # 遍历数据库（不一定能全部都遍历完，看时间是否足够）
    for db in server.db:
        # MAX_KEY_PER_DB 是一个 DB 最大能处理的 key 个数
        # 它保证时间不会全部用在个别的 DB 上（避免饥饿）
        i = 0
        while (i < MAX_KEY_PER_DB):
            # 数据库为空，跳出 while ，处理下个 DB
            if db.is_empty(): break
            # 随机取出一个带 TTL 的键
            key_with_ttl = db.expires.get_random_key()
            # 检查键是否过期，如果是的话，将它删除
            if is_expired(key_with_ttl):
                db.deleteExpiredKey(key_with_ttl)
            # 当执行时间到达上限，函数就返回，不再继续
            # 这确保删除操作不会占用太多的 CPU 时间
            if reach_time_limit(): return
            i += 1
```

    （1）函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。
    （2）全局变量current_db会记录当前activeExpireCycle函数的检查进度，并在下一次activeExpireCycle调用时，接着上一次的进度进行处理。
    （3）随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，当到达最后时，把current_db设置为0，然后又重新开始，如此循环下去。
    
### 如果有大量的key需要设置同一时间过期，一般需要注意什么？
如果大量的key过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。

也可以通过调大server.hz参数，即这个是过期键定期删除的频率，由配置文件中的hz参数决定，代表了一秒钟内后台任务期望被调用的次数。Redis 3.0.0中的默认值是10，代表每秒钟调用10次后台任务。
hz调大将会提高Redis主动淘汰的频率，若Redis存储中包含很多冷数据占用内存过大的话，可以考虑将这个值调大，但Redis作者建议这个值不要超过100。实际线上将这个值调大到 100 ，观察到 CPU 会增加 2% 左右，但对冷数据的内存释放速度确实有明显的提高（通过观察 keyspace 个数和 used_memory 大小）。
    
## Redis有哪几种数据“淘汰”策略
当mem_used内存已经超过maxmemory的设定，对于所有的读写请求，都会触发redis.c/freeMemoryIfNeeded(void)函数以清理超出的内存。注意这个清理过程是阻塞的，直到清理出足够的内存空间。所以如果在达到maxmemory并且调用方还在不断写入的情况下，可能会反复触发主动清理策略，导致请求会有一定的延迟。那么如何配置淘汰策略呢？

    通过配置redis.conf中的maxmemory这个值来开启内存淘汰功能。maxmemory为0的时候表示我们对Redis的内存使用没有限制。
    通过maxmemory-policy noeviction配置来选择淘汰策略
    
此外，redis支持动态改配置，无需重启。动态改配置命令如下：
    
    （1）设置最大内存：config set maxmemory 100000
    （2）设置淘汰策略：config set maxmemory-policy noeviction

配置淘汰策略的建议：

    （1）尽量不要触发maxmemory，最好在mem_used内存占用达到maxmemory的一定比例后，需要考虑调大hz以加快淘汰，或者进行集群扩容。
    （2）如果能够控制住内存，则可以不用修改maxmemory-samples配置；如果Redis本身就作为LRU cache服务（这种服务一般长时间处于maxmemory状态，由Redis自动做LRU淘汰），可以适当调大maxmemory-samples。

### 内存淘汰策略

    （1）volatile-lru
        从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。
        redis并不是保证取得所有数据集中最近最少使用的键值对，而只是随机挑选的几个键值对中的最少使用的数据，当内存达到限制时，对于没有带过期时间的写请求不提供服务。
    （2）volatile-ttl
        从已设置过期时间的数据集中挑选将要过期的数据淘汰。
        redis并不是保证取得所有数据集中最近将要过期的键值对，而只是随机挑选的几个键值对中的，当内存达到限制时，对于没有带过期时间的写请求不提供服务。

    （3）volatile-random
        从已设置过期时间的数据集中任意选择数据淘汰。当内存达到限制时，对于没有带过期时间的写请求不提供服务。
        
    （4）allkeys-lru
        从数据集中挑选最近最少使用的数据淘汰。当内存达到限制的时候，对所有数据集挑选最近最少使用的数据淘汰，可写入新的数据集。

    （5）allkeys-random
        从数据集中任意选择数据淘汰，当内存达到限制的时候，对所有数据集挑选随机淘汰，可写入新的数据集。

    （6）no-enviction
        当内存达到限制的时候，不淘汰任何数据，对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）
    （7）volatile-lfu：在设置了过期时间的key中使用LFU算法淘汰key
    （8）allkeys-lfu：在所有的key中使用LFU算法淘汰数据
        
### Redis LRU算法        
Redis使用的是近似LRU算法，它跟常规的LRU算法还不太一样。近似LRU算法通过随机采样法淘汰数据，每次随机出5（默认）个key，从里面淘汰掉最近最少使用的key。这意味着Redis不能选择最佳候选键来回收，也就是最久未被访问的那些键。可以通过maxmemory-samples参数修改采样数量。
```
// 配置的越大，淘汰的结果越接近于严格的LRU算法，但是会导致在主动清理时消耗更多的CPU时间
maxmemory-samples 10 maxmenory-samples
```
Redis为了实现近似LRU算法，给每个key增加了一个额外增加了一个24bit的字段，用来存储该key最后一次被访问的时间。
Redis3.0对近似LRU算法进行了一些优化。新算法会维护一个候选池（大小为16），池中的数据根据访问时间进行排序，第一次随机选取的key都会放入池中，随后每次随机选取的key只有在访问时间小于池中最小（最久没被访问）的时间才会放入池中，直到候选池被放满。当放满后，如果有新的key需要放入，则将池中最后访问时间最大（最近被访问）的移除。当需要淘汰的时候，则直接从池中选取最近访问时间最小（最久没被访问）的key淘汰掉就行。
Redis没有使用真正实现严格的LRU算法的原因是，因为消耗更多的内存。然而对于使用Redis的应用来说，使用近似的LRU算法，事实上是等价的。

### Redis LFU算法 
LFU算法是Redis4.0里面新加的一种淘汰策略。它的核心思想是根据key的最近被访问的频率进行淘汰，很少被访问的优先被淘汰，被访问的多的则被留下来。

LFU算法能更好的表示一个key被访问的热度。假如使用的是LRU算法，一个key很久没有被访问到，只刚刚是偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰，而有些key将来是很有可能被访问到的则被淘汰了。如果使用LFU算法则不会出现这种情况，因为使用一次并不会使一个key成为热点数据。

设置使用这两种淘汰策略跟前面讲的一样，不过要注意的一点是这两周策略只能在Redis4.0及以上设置，如果在Redis4.0以下设置会报错
### 如何选择淘汰策略
    （1）allkeys-lru：若应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者不太清楚应用的缓存访问分布状况，可以选择allkeys-lru策略。
    （2）allkeys-random：应用对于缓存key的访问概率相等，则可以使用这个策略。
    （3）volatile-ttl：这种策略可以向Redis提示哪些key更适合被eviction。

另外，volatile-lru策略和volatile-random策略适合将一个Redis实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个Redis实例来达到相同的效果，值得一提的是将key设置过期时间实际上会消耗更多的内存，因此我们建议使用allkeys-lru策略从而更有效率的使用内存。

**问题：**MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？（即如何保证热点数据不要被淘汰）
要保证热点数据不被淘汰，那么需要选择volatile-lru或allkeys-lru这两个基于LRU算法的淘汰策略。相比较来说，最终会选择allkeys-lru淘汰策略。若应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者不太清楚应用的缓存访问分布状况，可以选择allkeys-lru 策略。如果在Redis 4.0版本，可以考虑使用volatile-lfu，更加符合“热”的概念，频率越高，代表越热。

